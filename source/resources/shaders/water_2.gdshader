shader_type spatial;
#include "helpers.gdshaderinc"
#include "simplex_noise.gdshaderinc"

const int CHARACTER_POSITIONS_SIZE = 20;
const float SMOOTHSTEP_AA = 0.01;
uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;
//uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform float beer_factor = 0.8;

uniform float foam_distance = 0.01;
uniform float foam_max_distance = 0.4;
uniform float foam_min_distance = 0.04;
uniform vec4 foam_color: source_color  = vec4(1.0);

uniform vec2 surface_noise_tiling = vec2(1.0, 4.0);
uniform vec3 surface_noise_scroll = vec3(0.03, 0.03, 0.0);
uniform float surface_noise_cutoff: hint_range(0, 1) = 0.777;
uniform float surface_distortion_amount: hint_range(0, 1) = 0.27;
uniform sampler2D surfaceNoise;
uniform sampler2D distortNoise;

uniform float _DepthMaxDistance: hint_range(0, 1) = 1.0;
uniform float _DepthFactor = 1.0;
uniform vec4 _DepthGradientShallow : source_color;
uniform vec4 _DepthGradientDeep : source_color;

//uniform vec3[CHARACTER_POSITIONS_SIZE] character_positions;
//uniform float character_wave_radius = 3.0;
//uniform float character_wave_height = 1.0;
//uniform float character_wave_speed = 2.0;
//uniform float character_wave_frequency = 100.0;

uniform sampler2D noise_1;
uniform sampler2D noise_2;
//uniform float near = 0.1;
//uniform float far = 100.0;

varying vec3 world_vert;
varying float vertex_offset_y;
varying vec2 noiseUV;
varying vec2 distortUV;
varying vec3 viewNormal;

//float edge(float depth) {
//	depth = 2.0 * depth - 1.0;
//	return near * far / (far + depth * (near - far));
//}

void vertex() {
	viewNormal = (MODELVIEW_MATRIX * vec4(NORMAL, 0.0)).xyz;
	noiseUV = UV * surface_noise_tiling;
	distortUV = UV;
	
	world_vert = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
//	float char_pos_size_f = float(CHARACTER_POSITIONS_SIZE);
//	vertex_offset_y = 0.0;
//	for (float f = 0.0; f < char_pos_size_f; f += 1.0) {
//		vec3 character_position = character_positions[int(f)];
//		vec3 world_char_offset = world_vert - character_position;
//		vec3 offset_vert = (inverse(MODEL_MATRIX) * vec4(world_char_offset, 1.0)).xyz;
//		float circle_vert = offset_vert.x * offset_vert.x + offset_vert.z * offset_vert.z;
//		float value = character_wave_height * 
//			sin(length(offset_vert) * character_wave_frequency - TIME * character_wave_speed);
//		vertex_offset_y += value * 
//			(1.0 - smoothstep(0.0, character_wave_radius, length(world_char_offset))) *
//			smoothstep(0.0, character_wave_radius, length(offset_vert));
//	}
//	VERTEX.y += vertex_offset_y;
}

void fragment(){
	// https://www.youtube.com/watch?v=Jq3he9Lbj7M
	float depthVal = texture(DEPTH_TEXTURE, SCREEN_UV).r;
	float depth = PROJECTION_MATRIX[3][2] / (depthVal + PROJECTION_MATRIX[2][2]);
	depth = depth + VERTEX.z;
	depth = exp(-depth * beer_factor);
	depth = 1.0 - depth;
	
	float waterDepth = clamp(depth / _DepthMaxDistance, 0.0, 1.0) * _DepthFactor;
	vec4 waterColor = mix(_DepthGradientShallow, _DepthGradientDeep, waterDepth);
	
	// Still unsure how to get properly the NORMAL from the camera
	// This was generated by ChatGPT xD
	vec4 view_pos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV * 2.0 - 1.0, depthVal, 1.0);
	view_pos /= view_pos.w;
	vec3 existingNormal = normalize(cross( dFdx(view_pos.xyz), dFdy(view_pos.xyz)));

	float normalDot = clamp(dot(existingNormal.xyz, viewNormal), 0.0, 1.0);
	float foamDistance = mix(foam_max_distance, foam_min_distance, normalDot);

	float foamDepth = clamp(depth / foamDistance, 0.0, 1.0);
	float surfaceNoiseCutoff = foamDepth * surface_noise_cutoff;

	vec4 distortNoiseSample = texture(distortNoise, distortUV);
	vec2 distortAmount = (distortNoiseSample.xy * 2.0 -1.0) * surface_distortion_amount;

	vec2 noise_uv = vec2(
		(noiseUV.x + TIME * surface_noise_scroll.x) + distortAmount.x , 
		(noiseUV.y + TIME * surface_noise_scroll.y + distortAmount.y)
	);
	float surfaceNoiseSample = texture(surfaceNoise, noise_uv).r;
	float surfaceNoiseAmount = smoothstep(surfaceNoiseCutoff - SMOOTHSTEP_AA, 
		surfaceNoiseCutoff + SMOOTHSTEP_AA, surfaceNoiseSample);
	
	vec4 surfaceNoiseColor = foam_color;
    surfaceNoiseColor.a *= surfaceNoiseAmount;
	vec4 color = alpha_blend(surfaceNoiseColor, waterColor);
	
	// Caustics
	vec3 caustics_uv = world_vert;
	caustics_uv.y = TIME * 0.05;
    caustics_uv *= 2.0;
	vec4 n = snoise(caustics_uv);        
	caustics_uv -= 0.07 * n.xyz;
	n = snoise(caustics_uv);
	caustics_uv -= 0.07 * n.xyz;
	n = snoise(caustics_uv);
	float intensity = exp(n.w * 3. - 3.0);
	
	// displacement (not working correctly)
//	vec4 noise_1_sample = texture(noise_1, UV + vec2(1.0, 0.0) * sin(TIME) * 0.01);
//	vec4 noise_2_sample = texture(noise_2, UV + vec2(0.0, 1.0) * cos(TIME) * 0.01);
//
//	float z_depth = edge(depthVal);
//	float z_pos = edge(FRAGCOORD.z);
//	float diff = z_depth - z_pos;
//
//	float noise_sum = noise_1_sample.r + noise_2_sample.r - 1.0;
//	vec2 displacement = vec2(noise_sum * 0.01);
//	diff += displacement.x * 50.0;
//
//	vec4 screen = texture(SCREEN_TEXTURE, SCREEN_UV + displacement);
	
//	float fin = step(0.0, noise_sum) * step(noise_sum, 0.4) * 0.1 + 
//		step(0.4, noise_sum) * step(noise_sum, 0.8) * 0.0 + 
//		step(0.8, noise_sum) * 1.0;
	
//	ALBEDO = vec3(fin) + color.rgb;
//	float vert_offset_normalized = vertex_offset_y * 10.0 * character_wave_height;
//	ALBEDO = mix(color.rgb, foam_color.rgb, vert_offset_normalized);
//	ALPHA = mix(color.a, 1.0, vert_offset_normalized);
	ALBEDO = color.rgb;
	ALPHA = color.a;
	EMISSION = vec3(intensity);
}