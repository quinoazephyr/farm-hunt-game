shader_type spatial;
render_mode unshaded;
#include "helpers.gdshaderinc"

const int CHARACTER_POSITIONS_SIZE = 20;
const float SMOOTHSTEP_AA = 0.01;
uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform float beer_factor = 0.8;

uniform float foam_distance = 0.01;
uniform float foam_max_distance = 0.4;
uniform float foam_min_distance = 0.04;
uniform vec4 foam_color: source_color  = vec4(1.0);

uniform vec2 surface_noise_tiling = vec2(1.0, 4.0);
uniform vec3 surface_noise_scroll = vec3(0.03, 0.03, 0.0);
uniform float surface_noise_cutoff: hint_range(0, 1) = 0.777;
uniform float surface_distortion_amount: hint_range(0, 1) = 0.27;
uniform sampler2D surfaceNoise;
uniform sampler2D distortNoise;

uniform float _DepthMaxDistance: hint_range(0, 1) = 1.0;
uniform float _DepthFactor = 1.0;
uniform vec4 _DepthGradientShallow : source_color;
uniform vec4 _DepthGradientDeep : source_color;

uniform sampler2D simulation_texture;

uniform float wave_height = 0.01;
uniform float refraction = 0.1;

uniform sampler2D noise_1;
uniform sampler2D noise_2;

varying vec3 world_vert;
varying float vertex_offset_y;
varying vec2 noiseUV;
varying vec2 distortUV;
varying vec3 viewNormal;
varying vec4 simulation_sample;
varying vec3 wave_normal;

void vertex() {
	viewNormal = (MODELVIEW_MATRIX * vec4(NORMAL, 0.0)).xyz;
	noiseUV = UV * surface_noise_tiling;
	distortUV = UV;
	
	vec3 duv = vec3(4.0 / 512.0, 4.0 / 512.0, 0);
	float v1 = texture(simulation_texture, UV - duv.xz).y;
	float v2 = texture(simulation_texture, UV + duv.xz).y;
	float v3 = texture(simulation_texture, UV - duv.zy).y;
	float v4 = texture(simulation_texture, UV + duv.zy).y;

	wave_normal = normalize(vec3(v1 - v2, v3 - v4, 0.3)) * refraction;
	
	world_vert = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
	simulation_sample = texture(simulation_texture, UV);
	
	VERTEX += wave_normal * wave_height * simulation_sample.r;
}

void fragment(){
	vec4 screen_refraction = texture(SCREEN_TEXTURE, SCREEN_UV + wave_normal.xy);
	
	// displacement
	vec4 noise_1_sample = texture(noise_1, UV + vec2(1.0, 0.0) * -TIME * 0.01);
	vec4 noise_2_sample = texture(noise_2, UV + vec2(0.0, 1.0) * -TIME * 0.01);
	
	float noise_sum = noise_1_sample.r + noise_2_sample.r - 1.0;
	float fin = step(0.0, noise_sum) * step(noise_sum, 0.4) * 0.1 + 
		step(0.4, noise_sum) * step(noise_sum, 0.8) * 0.0 + 
		step(0.8, noise_sum) * 1.0;
	vec2 displacement = wave_normal.xy + vec2(noise_sum * 0.05);
	
	// https://www.youtube.com/watch?v=Jq3he9Lbj7M
	float depthVal = texture(DEPTH_TEXTURE, SCREEN_UV).r;
	float depth = PROJECTION_MATRIX[3][2] / (depthVal + PROJECTION_MATRIX[2][2]);
	depth = depth + VERTEX.z;
	depth = exp(-depth * beer_factor);
	depth = 1.0 - depth;
	float waterDepth = clamp(depth / _DepthMaxDistance, 0.0, 1.0) * _DepthFactor;
	vec4 waterColor = mix(_DepthGradientShallow, _DepthGradientDeep, waterDepth);
	
	float depthValDis = texture(DEPTH_TEXTURE, SCREEN_UV + displacement).r;
	float depthDis = PROJECTION_MATRIX[3][2] / (depthValDis + PROJECTION_MATRIX[2][2]);
	depthDis = depthDis + VERTEX.z;
	depthDis = exp(-depthDis * beer_factor);
	depthDis = 1.0 - depthDis;
	float waterDepthDis = clamp(depthDis / _DepthMaxDistance, 0.0, 1.0) * _DepthFactor;
	vec4 waterColorDis = mix(_DepthGradientShallow, _DepthGradientDeep, waterDepthDis);
	
	// Still unsure how to get properly the NORMAL from the camera
	// This was generated by ChatGPT xD
	vec4 view_pos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV * 2.0 - 1.0, depthVal, 1.0);
	view_pos /= view_pos.w;
	vec3 existingNormal = normalize(cross( dFdx(view_pos.xyz), dFdy(view_pos.xyz)));

	float normalDot = clamp(dot(existingNormal.xyz, viewNormal), 0.0, 1.0);
	float foamDistance = mix(foam_max_distance, foam_min_distance, normalDot);

	float foamDepth = clamp(depth / foamDistance, 0.0, 1.0);
	float surfaceNoiseCutoff = foamDepth * surface_noise_cutoff;

	vec4 distortNoiseSample = texture(distortNoise, distortUV);
	vec2 distortAmount = (distortNoiseSample.xy * 2.0 -1.0) * surface_distortion_amount;

	vec2 noise_uv = vec2(
		(noiseUV.x + TIME * surface_noise_scroll.x) + distortAmount.x , 
		(noiseUV.y + TIME * surface_noise_scroll.y + distortAmount.y)
	);
	float surfaceNoiseSample = texture(surfaceNoise, noise_uv).r;
	float surfaceNoiseAmount = smoothstep(surfaceNoiseCutoff - SMOOTHSTEP_AA, 
		surfaceNoiseCutoff + SMOOTHSTEP_AA, surfaceNoiseSample);
	
	vec4 surfaceNoiseColor = foam_color;
	surfaceNoiseColor.a *= surfaceNoiseAmount;
	
	vec4 color = alpha_blend(surfaceNoiseColor, waterColor);
	vec4 colorDis = alpha_blend(surfaceNoiseColor, waterColorDis);
	
	// underwater
	float underwater = step(0.01, waterDepthDis);
	vec4 screen_underwater = underwater * texture(SCREEN_TEXTURE, SCREEN_UV + displacement);
	vec4 screen = (1.0 - underwater) * texture(SCREEN_TEXTURE, SCREEN_UV);
	
	color = mix(screen, color, color.a);
	colorDis = mix(screen_underwater, colorDis, colorDis.a);
	
	vec3 final_color = mix(color.rgb, colorDis.rgb, underwater);
	
	ALBEDO = final_color;
}